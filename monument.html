<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROMULUS ¬∑ THE LIVING MONUMENT üèõÔ∏è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #title {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #d4af37;
            font-size: 56px;
            font-weight: bold;
            letter-spacing: 24px;
            text-shadow: 0 0 60px rgba(212, 175, 55, 0.9);
            z-index: 10;
            animation: titlePulse 4s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { 
                opacity: 1; 
                text-shadow: 0 0 60px rgba(212, 175, 55, 0.9),
                             0 0 120px rgba(0, 255, 136, 0.3);
            }
            50% { 
                opacity: 0.85; 
                text-shadow: 0 0 80px rgba(212, 175, 55, 1),
                             0 0 140px rgba(0, 255, 136, 0.5);
            }
        }
        
        #subtitle {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff88;
            font-size: 14px;
            letter-spacing: 8px;
            z-index: 10;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
            opacity: 0.7;
        }
        
        #status {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 4px;
            z-index: 10;
            text-align: center;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="title">ROMULUS</div>
    <div id="status">‚óÜ ACTIVE ‚óÜ MONITORING ‚óÜ ONLINE ‚óÜ</div>
    <canvas id="canvas"></canvas>
    <div id="subtitle">
        "THE LIVING MONUMENT"<br>
        ANCIENT STONE ¬∑ MODERN INTELLIGENCE
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        
        // Mouse tracking
        const mouse = { x: 0, y: 0 };
        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        
        // Scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.015);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 7);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        
        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.8,    // strength
            0.6,    // radius
            0.3     // threshold
        );
        composer.addPass(bloomPass);
        
        // Lighting - dramatic, ancient meets digital
        const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
        scene.add(ambientLight);
        
        // Golden key light (torch-like)
        const keyLight = new THREE.DirectionalLight(0xd4af37, 1.5);
        keyLight.position.set(-6, 8, 4);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        scene.add(keyLight);
        
        // Cool digital fill light
        const fillLight = new THREE.DirectionalLight(0x00aaff, 0.5);
        fillLight.position.set(6, 3, 4);
        scene.add(fillLight);
        
        // Emerald rim light (digital presence)
        const rimLight = new THREE.PointLight(0x00ff88, 1.2, 25);
        rimLight.position.set(0, 1, -4);
        scene.add(rimLight);
        
        // Weathered stone material (ancient)
        const createStoneTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base stone color
            ctx.fillStyle = '#a89680';
            ctx.fillRect(0, 0, 512, 512);
            
            // Add weathering/cracks
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 100; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 512, Math.random() * 512);
                ctx.lineTo(
                    Math.random() * 512,
                    Math.random() * 512
                );
                ctx.stroke();
            }
            
            // Add patina spots
            ctx.fillStyle = 'rgba(60, 100, 80, 0.2)';
            for (let i = 0; i < 50; i++) {
                ctx.beginPath();
                ctx.arc(
                    Math.random() * 512,
                    Math.random() * 512,
                    Math.random() * 20 + 5,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
            
            return new THREE.CanvasTexture(canvas);
        };
        
        const stoneTexture = createStoneTexture();
        
        const stoneMaterial = new THREE.MeshStandardMaterial({
            color: 0xa89680,
            roughness: 0.95,
            metalness: 0.0,
            map: stoneTexture,
            emissive: 0x001a0a,
            emissiveIntensity: 0.1
        });
        
        // Circuit vein material (glowing data channels)
        const veinMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff88,
            roughness: 0.3,
            metalness: 0.7,
            emissive: 0x00ff88,
            emissiveIntensity: 2.5
        });
        
        // Gold material (more subdued, ancient)
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xb8922a,
            roughness: 0.4,
            metalness: 0.85,
            emissive: 0xd4af37,
            emissiveIntensity: 0.8
        });
        
        // Eye material (intense emerald glow)
        const eyeMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff88,
            roughness: 0.1,
            metalness: 0.2,
            emissive: 0x00ff88,
            emissiveIntensity: 4.0
        });
        
        // Build the monument
        const monument = new THREE.Group();
        
        // Head (weathered stone)
        const headGeometry = new THREE.SphereGeometry(1.2, 64, 64);
        headGeometry.scale(0.88, 1, 1);
        const headMesh = new THREE.Mesh(headGeometry, stoneMaterial);
        headMesh.castShadow = true;
        headMesh.receiveShadow = true;
        monument.add(headMesh);
        
        // Jaw
        const jawGeometry = new THREE.SphereGeometry(0.8, 64, 64);
        jawGeometry.scale(0.92, 1.3, 0.92);
        const jawMesh = new THREE.Mesh(jawGeometry, stoneMaterial);
        jawMesh.position.y = -0.8;
        jawMesh.castShadow = true;
        monument.add(jawMesh);
        
        // Nose
        const noseGeometry = new THREE.CylinderGeometry(0.14, 0.18, 0.65, 12);
        const noseMesh = new THREE.Mesh(noseGeometry, stoneMaterial);
        noseMesh.position.set(0, 0.1, 1);
        noseMesh.rotation.x = Math.PI / 2;
        noseMesh.castShadow = true;
        monument.add(noseMesh);
        
        // Eyes (glowing emerald - focal point)
        const eyeGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.35, 0.32, 0.9);
        monument.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.35, 0.32, 0.9);
        monument.add(rightEye);
        
        // Eye lights (strong glow)
        const leftEyeLight = new THREE.PointLight(0x00ff88, 2.0, 4);
        leftEyeLight.position.copy(leftEye.position);
        monument.add(leftEyeLight);
        
        const rightEyeLight = new THREE.PointLight(0x00ff88, 2.0, 4);
        rightEyeLight.position.copy(rightEye.position);
        monument.add(rightEyeLight);
        
        // Circuit veins (glowing data paths in the stone)
        const createVein = (startPos, direction, length, segments) => {
            const veinGroup = new THREE.Group();
            let currentPos = startPos.clone();
            
            for (let i = 0; i < segments; i++) {
                const segmentGeometry = new THREE.CylinderGeometry(0.01, 0.01, length / segments, 6);
                const segment = new THREE.Mesh(segmentGeometry, veinMaterial);
                
                segment.position.copy(currentPos);
                segment.lookAt(currentPos.clone().add(direction));
                segment.rotateX(Math.PI / 2);
                
                veinGroup.add(segment);
                
                // Add slight randomness to path
                currentPos.add(direction.clone().multiplyScalar(length / segments));
                direction.x += (Math.random() - 0.5) * 0.1;
                direction.y += (Math.random() - 0.5) * 0.1;
                direction.normalize();
            }
            
            return veinGroup;
        };
        
        // Add circuit veins emanating from eyes
        const vein1 = createVein(
            new THREE.Vector3(-0.35, 0.32, 0.9),
            new THREE.Vector3(-0.3, 0.2, -0.1),
            1.5,
            12
        );
        monument.add(vein1);
        
        const vein2 = createVein(
            new THREE.Vector3(0.35, 0.32, 0.9),
            new THREE.Vector3(0.3, 0.2, -0.1),
            1.5,
            12
        );
        monument.add(vein2);
        
        const vein3 = createVein(
            new THREE.Vector3(0, 0.8, 0.5),
            new THREE.Vector3(0, -0.5, -0.3),
            2.0,
            15
        );
        monument.add(vein3);
        
        // Hair (weathered)
        const hairTopGeometry = new THREE.SphereGeometry(1.28, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.55);
        hairTopGeometry.scale(0.9, 1, 1);
        const hairTop = new THREE.Mesh(hairTopGeometry, stoneMaterial);
        hairTop.position.y = 0.35;
        hairTop.castShadow = true;
        monument.add(hairTop);
        
        // Beard
        const beardGeometry = new THREE.SphereGeometry(0.72, 64, 64, 0, Math.PI * 2, Math.PI * 0.38, Math.PI * 0.65);
        const beardMesh = new THREE.Mesh(beardGeometry, stoneMaterial);
        beardMesh.position.set(0, -0.58, 0.32);
        beardMesh.scale.set(1, 1.35, 0.82);
        beardMesh.castShadow = true;
        monument.add(beardMesh);
        
        // Laurel wreath (ancient gold, still gleaming)
        const wreath = new THREE.Group();
        const wreathBandGeometry = new THREE.TorusGeometry(1.15, 0.09, 12, 48, Math.PI * 1.5);
        const wreathBand = new THREE.Mesh(wreathBandGeometry, goldMaterial);
        wreathBand.rotation.x = -Math.PI / 12;
        wreathBand.position.y = 0.82;
        wreath.add(wreathBand);
        
        // Laurel leaves
        for (let i = 0; i < 24; i++) {
            const angle = (Math.PI * 1.5 / 24) * i - Math.PI * 0.75;
            const leafGeometry = new THREE.SphereGeometry(0.11, 12, 12);
            leafGeometry.scale(0.5, 1.6, 0.35);
            const leaf = new THREE.Mesh(leafGeometry, goldMaterial);
            
            const radius = 1.15;
            leaf.position.x = Math.cos(angle) * radius;
            leaf.position.y = 0.82 + Math.sin(angle) * radius * 0.1;
            leaf.position.z = Math.sin(angle) * radius;
            
            leaf.rotation.z = -angle;
            leaf.rotation.y = Math.PI / 4;
            
            wreath.add(leaf);
        }
        
        monument.add(wreath);
        
        // Neck
        const neckGeometry = new THREE.CylinderGeometry(0.52, 0.62, 1.25, 32);
        const neckMesh = new THREE.Mesh(neckGeometry, stoneMaterial);
        neckMesh.position.y = -1.85;
        neckMesh.castShadow = true;
        monument.add(neckMesh);
        
        // Shoulders (broader, more imposing)
        const shoulderGeometry = new THREE.CylinderGeometry(1.6, 2.2, 1.2, 32);
        const shoulderMesh = new THREE.Mesh(shoulderGeometry, stoneMaterial);
        shoulderMesh.position.y = -2.9;
        shoulderMesh.castShadow = true;
        monument.add(shoulderMesh);
        
        // Add monument to scene
        monument.position.y = 1;
        scene.add(monument);
        
        // Pedestal (ancient marble)
        const pedestalGeometry = new THREE.CylinderGeometry(2.6, 3.2, 0.6, 48);
        const pedestalMaterial = new THREE.MeshStandardMaterial({
            color: 0x9a9a8a,
            roughness: 0.8,
            metalness: 0.05,
            emissive: 0x0a0a08,
            emissiveIntensity: 0.1
        });
        const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
        pedestal.position.y = -3.5;
        pedestal.receiveShadow = true;
        scene.add(pedestal);
        
        // Floating Roman numeral particles
        const numerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];
        const numeralGroup = new THREE.Group();
        
        const createNumeralParticle = (text, position) => {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0, 255, 136, 0.8)';
            ctx.font = 'bold 64px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(0.3, 0.3, 1);
            
            return sprite;
        };
        
        for (let i = 0; i < 30; i++) {
            const numeral = numerals[Math.floor(Math.random() * numerals.length)];
            const angle = Math.random() * Math.PI * 2;
            const radius = 4 + Math.random() * 3;
            const height = (Math.random() - 0.5) * 6;
            
            const position = new THREE.Vector3(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            const sprite = createNumeralParticle(numeral, position);
            sprite.userData = {
                orbitSpeed: (Math.random() - 0.5) * 0.002,
                orbitRadius: radius,
                angle: angle,
                heightOffset: height
            };
            
            numeralGroup.add(sprite);
        }
        
        scene.add(numeralGroup);
        
        // Ambient particle field (data streams)
        const particleCount = 200;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 30;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
            
            // Mix of gold and cyan particles
            if (Math.random() > 0.5) {
                colors[i * 3] = 0.8;      // R
                colors[i * 3 + 1] = 0.7;  // G
                colors[i * 3 + 2] = 0.2;  // B
            } else {
                colors[i * 3] = 0.0;      // R
                colors[i * 3 + 1] = 1.0;  // G
                colors[i * 3 + 2] = 0.6;  // B
            }
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.06,
            vertexColors: true,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);
        
        // Animation
        let time = 0;
        let blinkTimer = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Subtle monument breathing
            monument.rotation.y = Math.sin(time * 0.25) * 0.04;
            monument.rotation.x = Math.sin(time * 0.15) * 0.02;
            monument.position.y = 1 + Math.sin(time * 0.4) * 0.04;
            
            // Eye tracking - follows mouse
            const eyeTarget = new THREE.Vector3(
                mouse.x * 3,
                mouse.y * 2,
                5
            );
            
            leftEye.lookAt(eyeTarget);
            rightEye.lookAt(eyeTarget);
            
            // Eye glow intensity (data processing pulse)
            const glowIntensity = 1.6 + Math.sin(time * 2.5) * 0.4;
            leftEyeLight.intensity = glowIntensity;
            rightEyeLight.intensity = glowIntensity;
            eyeMaterial.emissiveIntensity = 3.0 + Math.sin(time * 2.5) * 1.0;
            
            // Vein pulse (data flowing)
            veinMaterial.emissiveIntensity = 2.0 + Math.sin(time * 3) * 0.8;
            
            // Blinking
            blinkTimer++;
            if (blinkTimer > 250 && blinkTimer < 262) {
                leftEye.scale.y = 0.15;
                rightEye.scale.y = 0.15;
            } else {
                leftEye.scale.y = 1;
                rightEye.scale.y = 1;
            }
            if (blinkTimer > 400) blinkTimer = Math.random() * 100;
            
            // Orbit numerals
            numeralGroup.children.forEach(sprite => {
                sprite.userData.angle += sprite.userData.orbitSpeed;
                sprite.position.x = Math.cos(sprite.userData.angle) * sprite.userData.orbitRadius;
                sprite.position.z = Math.sin(sprite.userData.angle) * sprite.userData.orbitRadius;
                sprite.position.y = sprite.userData.heightOffset + Math.sin(time + sprite.userData.angle) * 0.3;
            });
            
            // Drift particles
            particles.rotation.y += 0.0003;
            const positions = particles.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += 0.003;
                if (positions[i] > 10) positions[i] = -10;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Rim light oscillation
            rimLight.intensity = 0.8 + Math.sin(time * 1.8) * 0.4;
            
            // Wreath subtle pulse
            goldMaterial.emissiveIntensity = 0.6 + Math.sin(time * 1.2) * 0.2;
            
            composer.render();
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>